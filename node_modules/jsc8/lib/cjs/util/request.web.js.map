{"version":3,"file":"request.web.js","sourceRoot":"","sources":["../../../src/util/request.web.ts"],"names":[],"mappings":";;AAKA,6BAA6D;AAG7D,yCAAsC;AACtC,+BAAwB;AAEX,QAAA,SAAS,GAAG,IAAI,CAAC;AAE9B,cAAiB,GAAM,EAAE,IAAiB;IACxC,MAAM,MAAM,GAAG,EAAO,CAAC;IACvB,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;QAClC,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAc,CAAC;YAAE,SAAS;QAC5C,MAAM,CAAC,GAAc,CAAC,GAAG,GAAG,CAAC,GAAc,CAAC,CAAC;KAC9C;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,uBAA8B,OAAe,EAAE,YAAiB;IAC9D,MAAM,YAAY,GAAG,WAAQ,CAAC,OAAO,CAAC,CAAC;IACvC,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE;QACjC,WAAW;QACX,gBAAgB;QAChB,YAAY;KACb,CAAC,CAAC;IACH,OAAO,iBACL,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAkB,EAC5D,EAAyB;QAEzB,MAAM,QAAQ,qBACT,YAAY,IACf,QAAQ,EAAE,GAAG,CAAC,QAAQ;gBACpB,CAAC,CAAC,YAAY,CAAC,QAAQ;oBACrB,CAAC,CAAC,mBAAQ,CAAC,YAAY,CAAC,QAAQ,EAAE,GAAG,CAAC,QAAQ,CAAC;oBAC/C,CAAC,CAAC,GAAG,CAAC,QAAQ;gBAChB,CAAC,CAAC,YAAY,CAAC,QAAQ,EACzB,MAAM,EAAE,GAAG,CAAC,MAAM;gBAChB,CAAC,CAAC,YAAY,CAAC,MAAM;oBACnB,CAAC,CAAC,GAAG,YAAY,CAAC,MAAM,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;oBACjD,CAAC,CAAC,GAAG,CAAC,MAAM;gBACd,CAAC,CAAC,YAAY,CAAC,MAAM,GACxB,CAAC;QAEF,IAAI,QAAQ,GAA0B,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YACjD,QAAQ,GAAG,GAAG,EAAE,CAAC,SAAS,CAAC;YAC3B,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QACf,CAAC,CAAC;QACF,MAAM,GAAG,GAAG,aAAG,iBAEX,YAAY,EAAE,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,IACzC,OAAO,IACV,GAAG,EAAE,YAAS,CAAC,QAAQ,CAAC,EACxB,MAAM,EAAE,IAAI,EACZ,IAAI;YACJ,MAAM;YACN,OAAO,KAET,CAAC,GAAiB,EAAE,GAAS,EAAE,EAAE;YAC/B,IAAI,CAAC,GAAG,EAAE;gBACR,IAAI,CAAC,GAAG,CAAC,IAAI;oBAAE,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC;gBAC7B,QAAQ,CAAC,IAAI,EAAE,GAAmB,CAAC,CAAC;aACrC;iBAAM;gBACL,MAAM,KAAK,GAAG,GAAgB,CAAC;gBAC/B,KAAK,CAAC,OAAO,GAAG,GAAG,CAAC;gBACpB,QAAQ,CAAC,KAAK,CAAC,CAAC;aACjB;QACH,CAAC,CACF,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AAnDD,sCAmDC","sourcesContent":["import {\n  C8jsError,\n  C8jsResponse,\n  RequestOptions\n} from \"./request.node\";\nimport { format as formatUrl, parse as parseUrl } from \"url\";\n\nimport { Errback } from \"./types\";\nimport { joinPath } from \"./joinPath\";\nimport xhr from \"./xhr\";\n\nexport const isBrowser = true;\n\nfunction omit<T>(obj: T, keys: (keyof T)[]): T {\n  const result = {} as T;\n  for (const key of Object.keys(obj)) {\n    if (keys.includes(key as keyof T)) continue;\n    result[key as keyof T] = obj[key as keyof T];\n  }\n  return result;\n}\n\nexport function createRequest(baseUrl: string, agentOptions: any) {\n  const baseUrlParts = parseUrl(baseUrl);\n  const options = omit(agentOptions, [\n    \"keepAlive\",\n    \"keepAliveMsecs\",\n    \"maxSockets\"\n  ]);\n  return function request(\n    { method, url, headers, body, expectBinary }: RequestOptions,\n    cb: Errback<C8jsResponse>\n  ) {\n    const urlParts = {\n      ...baseUrlParts,\n      pathname: url.pathname\n        ? baseUrlParts.pathname\n          ? joinPath(baseUrlParts.pathname, url.pathname)\n          : url.pathname\n        : baseUrlParts.pathname,\n      search: url.search\n        ? baseUrlParts.search\n          ? `${baseUrlParts.search}&${url.search.slice(1)}`\n          : url.search\n        : baseUrlParts.search\n    };\n\n    let callback: Errback<C8jsResponse> = (err, res) => {\n      callback = () => undefined;\n      cb(err, res);\n    };\n    const req = xhr(\n      {\n        responseType: expectBinary ? \"blob\" : \"text\",\n        ...options,\n        url: formatUrl(urlParts),\n        useXDR: true,\n        body,\n        method,\n        headers\n      },\n      (err: Error | null, res?: any) => {\n        if (!err) {\n          if (!res.body) res.body = \"\";\n          callback(null, res as C8jsResponse);\n        } else {\n          const error = err as C8jsError;\n          error.request = req;\n          callback(error);\n        }\n      }\n    );\n  };\n}\n"]}