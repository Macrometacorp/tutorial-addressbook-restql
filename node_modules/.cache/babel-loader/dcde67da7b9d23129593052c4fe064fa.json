{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"/home/guest/workspace/tutorials/tutorial-addressbook-restql/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/guest/workspace/tutorials/tutorial-addressbook-restql/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/guest/workspace/tutorials/tutorial-addressbook-restql/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _regeneratorRuntime = require(\"/home/guest/workspace/tutorials/tutorial-addressbook-restql/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/guest/workspace/tutorials/tutorial-addressbook-restql/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/guest/workspace/tutorials/tutorial-addressbook-restql/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar error_1 = require(\"./error\");\n\nvar stream_1 = require(\"./stream\");\n\nvar CollectionType;\n\n(function (CollectionType) {\n  CollectionType[CollectionType[\"DOCUMENT_COLLECTION\"] = 2] = \"DOCUMENT_COLLECTION\";\n  CollectionType[CollectionType[\"EDGE_COLLECTION\"] = 3] = \"EDGE_COLLECTION\";\n})(CollectionType = exports.CollectionType || (exports.CollectionType = {}));\n\nfunction isC8Collection(collection) {\n  return Boolean(collection && collection.isC8Collection);\n}\n\nexports.isC8Collection = isC8Collection;\nexports.DOCUMENT_NOT_FOUND = 1202;\nexports.COLLECTION_NOT_FOUND = 1203;\n\nvar BaseCollection =\n/*#__PURE__*/\nfunction () {\n  function BaseCollection(connection, name) {\n    _classCallCheck(this, BaseCollection);\n\n    this.isC8Collection = true;\n    this.name = name;\n    this._idPrefix = \"\".concat(this.name, \"/\");\n    this._connection = connection;\n    this.stream = new stream_1.Stream(connection, name, true);\n\n    if (this._connection.c8Major >= 3) {\n      this.createCapConstraint = undefined;\n    }\n  }\n\n  _createClass(BaseCollection, [{\n    key: \"_documentPath\",\n    value: function _documentPath(documentHandle) {\n      return \"/document/\".concat(this._documentHandle(documentHandle));\n    }\n  }, {\n    key: \"_documentHandle\",\n    value: function _documentHandle(documentHandle) {\n      if (typeof documentHandle !== \"string\") {\n        if (documentHandle._id) {\n          return documentHandle._id;\n        }\n\n        if (documentHandle._key) {\n          return this._idPrefix + documentHandle._key;\n        }\n\n        throw new Error(\"Document handle must be a document or string\");\n      }\n\n      if (documentHandle.indexOf(\"/\") === -1) {\n        return this._idPrefix + documentHandle;\n      }\n\n      return documentHandle;\n    }\n  }, {\n    key: \"_indexHandle\",\n    value: function _indexHandle(indexHandle) {\n      if (typeof indexHandle !== \"string\") {\n        if (indexHandle.id) {\n          return indexHandle.id;\n        }\n\n        throw new Error(\"Index handle must be a index or string\");\n      }\n\n      if (indexHandle.indexOf(\"/\") === -1) {\n        return this._idPrefix + indexHandle;\n      }\n\n      return indexHandle;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(path, qs) {\n      return this._connection.request({\n        path: \"/collection/\".concat(this.name, \"/\").concat(path),\n        qs: qs\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"_put\",\n    value: function _put(path, body) {\n      return this._connection.request({\n        method: \"PUT\",\n        path: \"/collection/\".concat(this.name, \"/\").concat(path),\n        body: body\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._connection.request({\n        path: \"/collection/\".concat(this.name)\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      return this.get().then(function () {\n        return true;\n      }, function (err) {\n        if (error_1.isC8Error(err) && err.errorNum === exports.COLLECTION_NOT_FOUND) {\n          return false;\n        }\n\n        throw err;\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create(properties) {\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/collection\",\n        body: Object.assign({}, properties, {\n          name: this.name,\n          type: this.type\n        })\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(callback, dcName) {\n      var subscriptionName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"subs\";\n      this.stream.consumer(subscriptionName, callback, dcName);\n    }\n  }, {\n    key: \"closeOnChangeConnection\",\n    value: function closeOnChangeConnection() {\n      this.stream.closeConnections();\n    }\n  }, {\n    key: \"properties\",\n    value: function properties() {\n      return this._get(\"properties\");\n    }\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this._get(\"count\");\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(name) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._connection.request({\n                  method: \"PUT\",\n                  path: \"/collection/\".concat(this.name, \"/rename\"),\n                  body: {\n                    name: name\n                  }\n                }, function (res) {\n                  return res.body;\n                });\n\n              case 2:\n                result = _context.sent;\n                this.name = name;\n                this._idPrefix = \"\".concat(name, \"/\");\n                return _context.abrupt(\"return\", result);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"truncate\",\n    value: function truncate() {\n      return this._put(\"truncate\", undefined);\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(opts) {\n      return this._connection.request({\n        method: \"DELETE\",\n        path: \"/collection/\".concat(this.name),\n        qs: opts\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"documentExists\",\n    value: function documentExists(documentHandle) {\n      return this._connection.request({\n        method: \"HEAD\",\n        path: \"/\".concat(this._documentPath(documentHandle))\n      }, function () {\n        return true;\n      }).catch(function (err) {\n        if (err.statusCode === 404) {\n          return false;\n        }\n\n        throw err;\n      });\n    }\n  }, {\n    key: \"document\",\n    value: function document(documentHandle) {\n      var graceful = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var result = this._connection.request({\n        path: \"/\".concat(this._documentPath(documentHandle))\n      }, function (res) {\n        return res.body;\n      });\n\n      if (!graceful) return result;\n      return result.catch(function (err) {\n        if (error_1.isC8Error(err) && err.errorNum === exports.DOCUMENT_NOT_FOUND) {\n          return null;\n        }\n\n        throw err;\n      });\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(documentHandle, newValue) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _a;\n\n      var headers = {};\n\n      if (typeof opts === \"string\") {\n        opts = {\n          rev: opts\n        };\n      }\n\n      if (opts.rev && this._connection.c8Major >= 3) {\n        var _a2;\n\n        var rev;\n        _a = opts, (_a2 = _a, rev = _a2.rev, _a2), opts = __rest(_a, [\"rev\"]);\n        headers[\"if-match\"] = rev;\n      }\n\n      return this._connection.request({\n        method: \"PUT\",\n        path: \"/\".concat(this._documentPath(documentHandle)),\n        body: newValue,\n        qs: opts,\n        headers: headers\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(documentHandle, newValue) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _a;\n\n      var headers = {};\n\n      if (typeof opts === \"string\") {\n        opts = {\n          rev: opts\n        };\n      }\n\n      if (opts.rev && this._connection.c8Major >= 3) {\n        var _a3;\n\n        var rev;\n        _a = opts, (_a3 = _a, rev = _a3.rev, _a3), opts = __rest(_a, [\"rev\"]);\n        headers[\"if-match\"] = rev;\n      }\n\n      return this._connection.request({\n        method: \"PATCH\",\n        path: \"/\".concat(this._documentPath(documentHandle)),\n        body: newValue,\n        qs: opts,\n        headers: headers\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(documentHandle) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      var headers = {};\n\n      if (typeof opts === \"string\") {\n        opts = {\n          rev: opts\n        };\n      }\n\n      if (opts.rev && this._connection.c8Major >= 3) {\n        var _a4;\n\n        var rev;\n        _a = opts, (_a4 = _a, rev = _a4.rev, _a4), opts = __rest(_a, [\"rev\"]);\n        headers[\"if-match\"] = rev;\n      }\n\n      return this._connection.request({\n        method: \"DELETE\",\n        path: \"/\".concat(this._documentPath(documentHandle)),\n        qs: opts,\n        headers: headers\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"import\",\n    value: function _import(data) {\n      var _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a$type = _a.type,\n          type = _a$type === void 0 ? \"auto\" : _a$type,\n          opts = __rest(_a, [\"type\"]);\n\n      if (Array.isArray(data)) {\n        data = data.map(function (line) {\n          return JSON.stringify(line);\n        }).join(\"\\r\\n\") + \"\\r\\n\";\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/import\",\n        body: data,\n        isBinary: true,\n        qs: Object.assign({\n          type: type === null ? undefined : type\n        }, opts, {\n          collection: this.name\n        })\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"indexes\",\n    value: function indexes() {\n      return this._connection.request({\n        path: \"/index\",\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body.indexes;\n      });\n    }\n  }, {\n    key: \"index\",\n    value: function index(indexHandle) {\n      return this._connection.request({\n        path: \"/index/\".concat(this._indexHandle(indexHandle))\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"createIndex\",\n    value: function createIndex(details) {\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/index\",\n        body: details,\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"dropIndex\",\n    value: function dropIndex(indexHandle) {\n      return this._connection.request({\n        method: \"DELETE\",\n        path: \"/index/\".concat(this._indexHandle(indexHandle))\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"createCapConstraint\",\n    value: function createCapConstraint(opts) {\n      if (typeof opts === \"number\") {\n        opts = {\n          size: opts\n        };\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/index\",\n        body: Object.assign({}, opts, {\n          type: \"cap\"\n        }),\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"createHashIndex\",\n    value: function createHashIndex(fields, opts) {\n      if (typeof fields === \"string\") {\n        fields = [fields];\n      }\n\n      if (typeof opts === \"boolean\") {\n        opts = {\n          unique: opts\n        };\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/index\",\n        body: Object.assign({\n          unique: false\n        }, opts, {\n          type: \"hash\",\n          fields: fields\n        }),\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"createSkipList\",\n    value: function createSkipList(fields, opts) {\n      if (typeof fields === \"string\") {\n        fields = [fields];\n      }\n\n      if (typeof opts === \"boolean\") {\n        opts = {\n          unique: opts\n        };\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/index\",\n        body: Object.assign({\n          unique: false\n        }, opts, {\n          type: \"skiplist\",\n          fields: fields\n        }),\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"createPersistentIndex\",\n    value: function createPersistentIndex(fields, opts) {\n      if (typeof fields === \"string\") {\n        fields = [fields];\n      }\n\n      if (typeof opts === \"boolean\") {\n        opts = {\n          unique: opts\n        };\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/index\",\n        body: Object.assign({\n          unique: false\n        }, opts, {\n          type: \"persistent\",\n          fields: fields\n        }),\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"createGeoIndex\",\n    value: function createGeoIndex(fields, opts) {\n      if (typeof fields === \"string\") {\n        fields = [fields];\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/index\",\n        body: Object.assign({}, opts, {\n          fields: fields,\n          type: \"geo\"\n        }),\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"createFulltextIndex\",\n    value: function createFulltextIndex(fields, minLength) {\n      if (typeof fields === \"string\") {\n        fields = [fields];\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/index\",\n        body: {\n          fields: fields,\n          minLength: minLength,\n          type: \"fulltext\"\n        },\n        qs: {\n          collection: this.name\n        }\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }]);\n\n  return BaseCollection;\n}();\n\nexports.BaseCollection = BaseCollection;\n\nvar DocumentCollection =\n/*#__PURE__*/\nfunction (_BaseCollection) {\n  _inherits(DocumentCollection, _BaseCollection);\n\n  function DocumentCollection(connection, name) {\n    var _this;\n\n    _classCallCheck(this, DocumentCollection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DocumentCollection).call(this, connection, name));\n    _this.type = CollectionType.DOCUMENT_COLLECTION;\n    return _this;\n  }\n\n  _createClass(DocumentCollection, [{\n    key: \"save\",\n    value: function save(data, opts) {\n      if (typeof opts === \"boolean\") {\n        opts = {\n          returnNew: opts\n        };\n      }\n\n      if (this._connection.c8Major <= 2) {\n        return this._connection.request({\n          method: \"POST\",\n          path: \"/document\",\n          body: data,\n          qs: Object.assign({}, opts, {\n            collection: this.name\n          })\n        }, function (res) {\n          return res.body;\n        });\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/document/\".concat(this.name),\n        body: data,\n        qs: opts\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }]);\n\n  return DocumentCollection;\n}(BaseCollection);\n\nexports.DocumentCollection = DocumentCollection;\n\nvar EdgeCollection =\n/*#__PURE__*/\nfunction (_BaseCollection2) {\n  _inherits(EdgeCollection, _BaseCollection2);\n\n  function EdgeCollection(connection, name) {\n    var _this2;\n\n    _classCallCheck(this, EdgeCollection);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeCollection).call(this, connection, name));\n    _this2.type = CollectionType.EDGE_COLLECTION;\n    return _this2;\n  }\n\n  _createClass(EdgeCollection, [{\n    key: \"_documentPath\",\n    value: function _documentPath(documentHandle) {\n      if (this._connection.c8Major < 3) {\n        return \"edge/\".concat(this._documentHandle(documentHandle));\n      }\n\n      return \"document/\".concat(this._documentHandle(documentHandle));\n    }\n  }, {\n    key: \"edge\",\n    value: function edge(documentHandle) {\n      var graceful = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.document(documentHandle, graceful);\n    }\n  }, {\n    key: \"save\",\n    value: function save(data, fromIdOrOpts, toId, opts) {\n      if (toId !== undefined) {\n        data._from = this._documentHandle(fromIdOrOpts);\n        data._to = this._documentHandle(toId);\n      } else if (fromIdOrOpts !== undefined) {\n        opts = fromIdOrOpts;\n      }\n\n      if (typeof opts === \"boolean\") {\n        opts = {\n          returnNew: opts\n        };\n      }\n\n      if (this._connection.c8Major <= 2) {\n        return this._connection.request({\n          method: \"POST\",\n          path: \"/edge\",\n          body: data,\n          qs: Object.assign({}, opts, {\n            collection: this.name,\n            from: data._from,\n            to: data._to\n          })\n        }, function (res) {\n          return res.body;\n        });\n      }\n\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/document\",\n        body: data,\n        qs: Object.assign({}, opts, {\n          collection: this.name\n        })\n      }, function (res) {\n        return res.body;\n      });\n    }\n  }, {\n    key: \"_edges\",\n    value: function _edges(documentHandle, direction) {\n      return this._connection.request({\n        path: \"/edges/\".concat(this.name),\n        qs: {\n          direction: direction,\n          vertex: this._documentHandle(documentHandle)\n        }\n      }, function (res) {\n        return res.body.edges;\n      });\n    }\n  }, {\n    key: \"edges\",\n    value: function edges(vertex) {\n      return this._edges(vertex, undefined);\n    }\n  }, {\n    key: \"inEdges\",\n    value: function inEdges(vertex) {\n      return this._edges(vertex, \"in\");\n    }\n  }, {\n    key: \"outEdges\",\n    value: function outEdges(vertex) {\n      return this._edges(vertex, \"out\");\n    }\n  }, {\n    key: \"traversal\",\n    value: function traversal(startVertex, opts) {\n      return this._connection.request({\n        method: \"POST\",\n        path: \"/traversal\",\n        body: Object.assign({}, opts, {\n          startVertex: startVertex,\n          edgeCollection: this.name\n        })\n      }, function (res) {\n        return res.body.result;\n      });\n    }\n  }]);\n\n  return EdgeCollection;\n}(BaseCollection);\n\nexports.EdgeCollection = EdgeCollection;\n\nfunction constructCollection(connection, data) {\n  var Collection = data.type === CollectionType.EDGE_COLLECTION ? EdgeCollection : DocumentCollection;\n  return new Collection(connection, data.name);\n}\n\nexports.constructCollection = constructCollection;","map":null,"metadata":{},"sourceType":"script"}